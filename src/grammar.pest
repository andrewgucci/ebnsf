// TODO: only really supports BNF syntax, need to add support for EBNF things like repitition specifiers

syntax = _{ SOI ~ rules ~ EOI }

rules = { rule+ }

rule = { lbrack ~ rule_name ~ rbrack ~ "::=" ~ expression ~ NEWLINE*}

// Expressions are composed of at least one list followed by zero or more optional variants
expression = { (list) ~ ( "\n"* ~ "|" ~ (list) )* }

// Lists are composed of zero or more terms
// Empty expressions aka group lists without terms are valid, if this is not intended then can be term+ instead.
list = { term* }

// Terms are composed of either grouped lists which can contain nested expressions, 
// or literals or rule names followed by an optional modifier
term = { grouped_list | (literal | lbrack ~ rule_name ~ rbrack) ~ opt_modifier }

// Grouped lists are composed of nested expressions wrapped in parenthesis followed by
// an optional modifier
grouped_list = { lparen ~ expression ~ rparen ~ opt_modifier }

opt_modifier = { (oper_cond | oper_alo | oper_rep)? }
oper_cond    = { "?" }
oper_alo     = { "+" } // alo = At Least One
oper_rep     = { "*" }

literal = @{
    "\"" ~ not_quote_or_nl+ ~ "\"" | 
    "'" ~ not_squote_or_nl+ ~ "'"
}

lbrack = _{ "<" }
rbrack = _{ ">" }
lparen = _{ "(" }
rparen = _{ ")" }

rule_name = { ASCII_ALPHA ~ (ASCII_ALPHA | ASCII_DIGIT | "_" | " " | "-")* }

WHITESPACE = _{ " " | "\t" }

// TODO: Need to handle escape characters at some point
not_quote_or_nl = {
    !(                // if the following text is not
        "\""          //     a quote
        | "\n"        //     or a newline
    )
    ~ ( "\\" ~ "\"" | ANY )             // then consume one character
}
not_squote_or_nl = {
    !(                // if the following text is not
        "\'"          //     a quote
        | "\n"        //     or a newline
    )
    ~ ( "\\" ~ "\'" | ANY )             // then consume one character
}
